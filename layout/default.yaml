layouts:
  # 项目 main 文件，
  - path: main.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator.
      
      package main
      
      import (
        "context"
        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/app/middlewares/server/recovery"
        "github.com/cloudwego/hertz/pkg/app/server"
        "github.com/cloudwego/hertz/pkg/app/server/registry"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        app2 "github.com/flyerxp/lib/app"
        conf2 "github.com/flyerxp/lib/config"
        "github.com/flyerxp/lib/logger"
        "github.com/flyerxp/lib/utils/netL"
        "github.com/flyerxp/webrpclib/web"
        hertzzap "github.com/hertz-contrib/logger/zap"
        "github.com/hertz-contrib/requestid"
        "{{.GoModule}}/biz/dal"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "gopkg.in/natefinch/lumberjack.v2"
        "net"
        "os"
        "{{.GoModule}}/biz/mw"
        "time"
      )
      
      func main() {
        time.LoadLocation("Asia/Shanghai") 
        c := web.GetConf()
        name := conf2.GetConf().App.Name
        ip := netL.GetIp()[0].(*net.IPNet).IP.String() + ":" + c.Hertz.Port
        ctx := logger.GetContext(context.Background(), "WebServerStart")
        h := web.GetHttpServer(ctx, &registry.Info{
          ServiceName: name,
          Addr:        utils.NewNetAddr("tcp", ip),
          Weight:      1,
          Tags: map[string]string{"type": "web", "name": name},
        })
        h.Use(mw.ClientIp())
        registerMiddle(h)     
        dal.InitDal(ctx)
        h.Use(requestid.New())
          h.OnShutdown = append(h.OnShutdown, func(ctx context.Context) {
          app2.Shutdown(ctx)
        })
        
        register(h)
        h.Spin()
      }
  
  
      func registerMiddle(r *server.Hertz) {
        registerLog(r)
        HzRecover(r)
      }
      func registerLog(r *server.Hertz) {
        level := zapcore.DebugLevel
        if conf2.GetConf().Env == "product" {
          level = zapcore.InfoLevel
        }
        l := hertzzap.NewLogger(
            hertzzap.WithCores([]hertzzap.CoreConfig{
            {
              Enc: zapcore.NewConsoleEncoder(logger.EncoderConfig()),
              Ws:  zapcore.AddSync(os.Stdout),
              Lvl: zap.NewAtomicLevelAt(level),
            },
            {
              Enc: zapcore.NewJSONEncoder(logger.EncoderConfig()),
              Ws:  getWriteSyncer("logs/hertz.log"),
              Lvl: zap.NewAtomicLevelAt(level),
            },
          }...),
        )
        r.OnShutdown = append(r.OnShutdown, func(ctx context.Context) {
          l.Sync()
          app2.Shutdown(ctx)
        })
        hlog.SetLogger(l)
      }
      func HzRecover(r *server.Hertz) {
        r.Use(recovery.Recovery(recovery.WithRecoveryHandler(func(c context.Context, ctx *app.RequestContext, err interface{}, stack []byte) {
          hlog.SystemLogger().CtxErrorf(c, "[Recovery] err=%v\nstack=%s", err, stack)
          hlog.SystemLogger().Infof("Client: %s", ctx.Request.Header.UserAgent())
          logger.AddError(c,zap.String("stack", string(stack)))
          logger.WriteLine(c)
          ctx.AbortWithStatus(consts.StatusInternalServerError)
        })))
      }
      func getWriteSyncer(file string) zapcore.WriteSyncer {
        lumberJackLogger := &lumberjack.Logger{
          Filename:   file,
          MaxSize:    1024 * 1024 * 1024,
          MaxBackups: 5,
          MaxAge:     48,
          Compress:   true,
          LocalTime:  true,
        }
        return zapcore.AddSync(lumberJackLogger)
      }


  # go.mod 文件，需要模板渲染数据{{.GoModule}}才能生成
  - path: go.mod
    delims:
      - '{{'
      - '}}'
    body: |-
      module {{.GoModule}}
      {{- if .UseApacheThrift}}
      replace github.com/apache/thrift => github.com/apache/thrift v0.13.0
      {{- end}}
  # .gitignore 文件
  - path: .gitignore
    delims:
      - ""
      - ""
    body: "*.o\n*.a\n*.so\n_obj\n_test\n*.[568vq]\n[568vq].out\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n_testmain.go\n*.exe\n*.exe~\n*.test\n*.prof\n*.rar\n*.zip\n*.gz\n*.psd\n*.bmd\n*.cfg\n*.pptx\n*.log\n*nohup.out\n*settings.pyc\n*.sublime-project\n*.sublime-workspace\n!.gitkeep\n.DS_Store\n/.idea\n/.vscode\n/output\n*.local.yml\ndumped_hertz_remote_config.json\n\t\t
    \ "
  # .hz 文件，包含 hz 版本，是 hz 创建的项目的标志，不需要传渲染数据
  - path: .hz
    delims:
      - '{{'
      - '}}'
    body: |-
      // Code generated by hz. DO NOT EDIT.

      hz version: {{.hzVersion}}

  # ping 自带 ping 的 handler
  - path: biz/handler/ping.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator.

      package handler

      import (
      	"context"

      	"github.com/cloudwego/hertz/pkg/app"
      	"github.com/cloudwego/hertz/pkg/common/utils"
      )

      // Ping .
      func Ping(ctx context.Context, c *app.RequestContext) {
      	c.JSON(200, utils.H{
      		"message": "pong",
      	})
      }     

  # 定义Dal
  - path: biz/dal/init.go
    delims:
      - ""
      - ""
    body: |-
      package dal
      
      import (
        "context"
      	"{{.GoModule}}/biz/dal/mysql"
      	"{{.GoModule}}/biz/dal/redis"
      )
      
      func InitDal(ctx context.Context) {
        mysql.InitMysql(ctx)
        redis.InitRedis(ctx)
      }

  # 定义DalMysql
  - path: biz/dal/mysql/init.go
    delims:
      - ""
      - ""
    body: |-
      package mysql
      
      import (
        "context"
        "github.com/flyerxp/lib/middleware/mysqlL"
      )
      
      // 定义所有的数据库连接,每个连接一个名字
      var ConnExample *mysqlL.MysqlClient
        
      func InitMysql(ctx context.Context) {
        ConnExample, _ = mysqlL.GetEngine(ctx,"pubMysql")
      }

  # 定义Dal Redis
  - path: biz/dal/redis/init.go
    delims:
      - ""
      - ""
    body: |-
      package redis
  
      import (
        "context"
        "github.com/flyerxp/lib/middleware/redisL"
      )
      
      var RedisExample *redisL.RedisC
      
      func InitRedis(ctx context.Context) {
        RedisExample, _ = redisL.GetEngine(ctx,"pubRedis")
      }

  - path: biz/utils/resp.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package utils

      import (
      	"context"
        "errors"
        "github.com/flyerxp/webrpclib/web"
        "github.com/osteele/liquid"
      	"github.com/cloudwego/hertz/pkg/app"
        "go.uber.org/zap"
        "os"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        "github.com/flyerxp/lib/logger"
        "github.com/flyerxp/lib/utils/json"
        "github.com/cloudwego/kitex/pkg/kerrors"
        "github.com/flyerxp/lib/config"
        "github.com/flyerxp/lib/logger"
        "path/filepath"
      )

    
      var globalVar TemplateGlobal
      
      type TemplateGlobal struct {
        User         map[string]string
        ImgDomain    string
        JsDomain     string
        CssDomain    string
        NodeJsDomain string
        Other        map[string]string
      }
      
      var TmplEngine *liquid.Engine
        
        func init() {
        initGlobal()
        initTmplCache()
      }
      func initGlobal() {
        globalVar = TemplateGlobal{
          ImgDomain:    web.GetConf().Resource.RootPathImg,
          JsDomain:     web.GetConf().Resource.RootPathJs,
          CssDomain:    web.GetConf().Resource.RootPathCss,
          NodeJsDomain: web.GetConf().Resource.RootPathNodeJs,
          Other:        make(map[string]string),
          User:         make(map[string]string),
        }
        if web.GetConf().Resource.Other != nil {
            for i, v := range web.GetConf().Resource.Other {
              globalVar.Other[i] = v
            }
        }
      }
      func initTmplCache() {
        if TmplEngine == nil {
          TmplEngine = liquid.NewEngine()
          TmplEngine.Delims("{[{", "}]}", "{%", "%}")
          registerBlock(TmplEngine)
          f, _ := filepath.Glob("render/html/include/*.html")
          for _, v := range f {
            b, _ := os.ReadFile(v)
            _, _ = TmplEngine.ParseTemplateAndCache(b, filepath.Base(v), 1)
          }
        }
      }

      const ErrorCodeBiz = 206          //业务错误
      const ErrorCodeVerification = 204 //校验错误
      const RpcError = 203              //rpc错误
      const RpcBizError = 202           //rpc 业务错误
      const ErrorTypeBizWaning = "warn"
      const ErrorTypeBizErr = "err"
      
      type Response struct {
        Status  int   `json:"status"`
        Message error `json:"message"`
        Data    any   `json:"data"`
      }
      type Error struct {
          ErrorType string            `json:"ErrorType"`
          Msg       string            `json:"Msg"`
          FailField string            `json:"FailField"`
          Meta      map[string]string `json:"Meta"`
      }
      func (e Error) Error() string {
        b, _ := json.Encode(e)
        return string(b)
      }

      func GetError(errType string, msg string, meta map[string]string) Error {
        r := Error{
          ErrorType: errType,
          Msg:       msg,
        }
        if v, ok := meta["FailField"]; ok {
          r.ErrorType = v
          delete(meta, "FailField")
        }
        return r
      }


      // SendErrResponse  pack error response
      func SendErrResponse(ctx context.Context, c *app.RequestContext,  code int, message string) {
        err := errors.New(message)
        if config.GetConf().Env == "product" {
          if code == RpcError {
            logger.AddError(ctx, zap.String("systemErr", err.Error()), zap.Error(err))
            err = errors.New("系统错误")
          }
        }
        var response Response
        if code == RpcError {
          response = Response{Status: ErrorCodeBiz, Message: GetError(ErrorTypeBizErr, err.Error(), map[string]string{}), Data: map[string]string{}}
        } else {
          response = Response{Status: ErrorCodeBiz, Message: GetError(ErrorTypeBizWaning, err.Error(), map[string]string{}), Data: map[string]string{}}
        }
        //c.SetContentType("application/json;charset:utf-8")
        c.JSON(consts.StatusOK, response)
      }     

      // SendSuccessResponse  pack success response
      func SendSuccessResponse(ctx context.Context, c *app.RequestContext, data interface{}) {
        // todo edit custom code
          response := Response{Status: 0, Message: nil, Data: data}
          c.JSON(200, response)
      }
  
      func RenderErrHtml(ctx context.Context, c *app.RequestContext, err error) {
        var b []byte
        data := map[string]any{
          "error": err,
        }
        if string(c.GetHeader("x-requested-with")) == "XMLHttpRequest" {
          data["error"] = err
          b, _ = os.ReadFile("render/html/public/errorpop.html")
        } else {
          data = getGlobalData(ctx, c, data)
          initTmplCache()
          b, _ = os.ReadFile("render/html/public/error.html")
        }
        b, err = TmplEngine.ParseAndRender(b, data)
        c.Data(505, "text/html; charset=utf-8", b)
      }
      func Render404Html(ctx context.Context, c *app.RequestContext, data map[string]any) {
        data = getGlobalData(ctx, c, data)
        initTmplCache()
        b, _ := os.ReadFile("render/html/public/error404.html")
        b, _ = TmplEngine.ParseAndRender(b, data)
        c.Data(404, "text/html; charset=utf-8", b)
      }
      func RenderSuccessHtml(ctx context.Context, c *app.RequestContext, name string, data map[string]any) {        
        data = getGlobalData(ctx, c, data)       
        initTmplCache()
        b, err := os.ReadFile(name)
        if err != nil {
          panic(err)
        }        
        b, err = TmplEngine.ParseAndRender(b, data)        
        if err != nil {
          panic(err)
        }
        c.Data(200, "text/html; charset=utf-8", b)  
      }
      func getGlobalData(ctx context.Context, c *app.RequestContext, data map[string]any) map[string]any {
        for i := range globalVar.Other {
          data["Global"+i] = globalVar.Other[i]
        }
        data["GlobalUid"] = 0
        data["GlobalUName"] = ""
        data["GlobalGName"] = ""    
        data["GlobalImgDomain"] = globalVar.ImgDomain
        data["GlobalJsDomain"] = globalVar.JsDomain
        data["GlobalCssDomain"] = globalVar.CssDomain
        data["GlobalNodeJsDomain"] = globalVar.NodeJsDomain
        data["GlobalOther"] = globalVar.Other
        return data
      }
  - path: biz/utils/page.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package utils
      
      import (
        "bytes"
        "fmt"
        "github.com/flyerxp/lib/utils/json"
        "github.com/osteele/liquid"
        "github.com/osteele/liquid/render"
        "net/url"
        "strconv"
      )
      
      type Page struct {
        Page    int    `json:"page"`
        Size    int    `json:"size"`
        HasMore bool   `json:"has_more"`
        Url     string `json:"url"`
      }

      func getPageHtml(path string, query url.Values, page Page) string {
        query.Del("page")
        var bt bytes.Buffer
        bt.WriteString(`<nav aria-label="...">
        <ul class="pagination pagination-sm">`)
        if page.Page > 1 {
          //prePage = fmt.Sprintf() (page-1)
          query.Set("page", strconv.Itoa(page.Page-1))
          bt.WriteString(fmt.Sprintf(`<li class="page-item disabled"><a class="page-link" href="%s?%s" tabindex="-1" aria-disabled="true">Previous</a>
          </li>`, path, query.Encode()))
          i := page.Page - 5
          if i < 1 {
          i = 1
        }
        for ; i < page.Page; i++ {
          query.Set("page", strconv.Itoa(i))
          bt.WriteString(fmt.Sprintf(`<li class="page-item"><a class="page-link" href="%s?%s">%d</a>
          </li>`, path, query.Encode(), i))
        }
      }
      query.Set("page", strconv.Itoa(page.Page))
        //bt.WriteString(fmt.Sprintf(`<li class="page-item active" aria-current="page"><a class="page-link" href="%s?%s">%d <span class="visually-hidden">(current)</span></a>
        //</li>`, path, query.Encode(), page.Page))
        bt.WriteString(fmt.Sprintf(`<li class="page-item active" aria-current="page"><a class="page-link" href="#">%d <span class="visually-hidden">(current)</span></a>
        </li>`, page.Page))
        if page.HasMore {
          query.Set("page", strconv.Itoa(page.Page+1))
          bt.WriteString(fmt.Sprintf(`<li class="page-item"><a class="page-link" href="%s?%s">下一页</a>
          </li>`, path, query.Encode()))
        }
        bt.WriteString(`</ul>
        </nav>`)
        return bt.String()
      }

      func registerBlock(engine *liquid.Engine) {
        engine.RegisterBlock("page", func(c render.Context) (string, error) {
        page := Page{}
        str, err := c.InnerString()
        if err != nil {
          return "", err
        }
        //e := json.Unmarshal([]byte(`{"page":1,"size":"10","hasMore":"true","url":"/asdfa/asdfadsf/8asdfads?asd=3&adsf,=4"'}`), &a)
        err = json.Decode([]byte(str), &page)
        if err != nil {
          return "", err
        }
        urlObj, _ := url.Parse(page.Url)
          query := urlObj.Query()
          query.Del("page")
          html := getPageHtml(urlObj.Path, query, page)
          return html, nil
        })
      }
  # 定义路由注册的文件，需要模板渲染数据{{.RouterPkgPath}}才能生成
  - path: router_gen.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator. DO NOT EDIT.

      package main

      import (
      	"github.com/cloudwego/hertz/pkg/app/server"
      	router "{{.RouterPkgPath}}"
      )

      // register registers all routers.
      func register(r *server.Hertz) {

      	router.GeneratedRegister(r)

      	customizedRegister(r)
      }

  # 自定义路由注册的文件
  - path: router.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator.

      package main

      import (
      	"github.com/cloudwego/hertz/pkg/app/server"
      	handler "{{.HandlerPkgPath}}"
      )

      // customizeRegister registers customize routers.
      func customizedRegister(r *server.Hertz){
      	r.GET("/ping",  handler.Ping)

      	// your code ...
      }

  - path: readme.md
    delims:
      - ""
      - ""
    body: |-
      # *** Project

      ## introduce

      - Use the [Hertz](https://github.com/cloudwego/hertz/) framework
      - Integration of pprof, cors, recovery, access_log, gzip and other extensions of Hertz.
      - Generating the base code for unit tests.
      - Provides basic profile functions.
      - Provides the most basic MVC code hierarchy.

      ## Directory structure

      |  catalog   | introduce  |
      |  ----  | ----  |
      | conf  | Configuration files |
      | main.go  | Startup file |
      | hertz_gen  | Hertz generated model |
      | biz/handler  | Used for request processing, validation and return of response. |
      | biz/service  | The actual business logic. |
      | biz/dal  | Logic for operating the storage layer |
      | biz/route  | Routing and middleware registration |
      | biz/utils  | Wrapped some common methods |

      ## How to run

      ```shell
      sh build.sh
      sh output/bootstrap.sh
      ```
  - path: build.sh
    delims:
      - "{{"
      - "}}"
    body: |-
      #!/bin/bash
      RUN_NAME={{.ServiceName}}
      mkdir -p output/bin output/conf
      cp script/bootstrap.sh output 2>/dev/null
      chmod +x output/bootstrap.sh
      cp -r conf/* output/conf
      go build -o output/bin/${RUN_NAME}

  - path: script/bootstrap.sh
    delims:
      - "{{"
      - "}}"
    body: |-
      #!/bin/bash
      CURDIR=$(cd $(dirname $0); pwd)
      BinaryName={{.ServiceName}}
      echo "$CURDIR/bin/${BinaryName}"
      exec $CURDIR/bin/${BinaryName}

  # 默认路由注册文件，不要修改
  - path: biz/router/register.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator. DO NOT EDIT.

      package router

      import (
      	"github.com/cloudwego/hertz/pkg/app/server"
      )

      // GeneratedRegister registers routers generated by IDL.
      func GeneratedRegister(r *server.Hertz){
      	//INSERT_POINT: DO NOT DELETE THIS LINE!
      }
  # ip获取修改
  - path: biz/mw/client.go
    delims:
      - ""
      - ""
    body: |-
      // 获取客户端的逻辑
      package mw
      
      import (
        "context"
        "github.com/cloudwego/hertz/pkg/app"
        "net"
      )
      
      func ClientIp() app.HandlerFunc {
           return func(ctx context.Context, c *app.RequestContext) {
            trustedIp := []*net.IPNet{
              { // 0.0.0.0/0 (IPv4)
                IP:   net.IP{0x0, 0x0, 0x0, 0x0},
                Mask: net.IPMask{0x0, 0x0, 0x0, 0x0},
              },
              { // ::/0 (IPv6)
                IP:   net.IP{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
                Mask: net.IPMask{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
              },
              { // ::/0 (IPv6)
                IP: net.ParseIP("127.0.0.1"),
              },
            }
            c.SetClientIPFunc(app.ClientIPWithOption(app.ClientIPOptions{
              RemoteIPHeaders: []string{"X-Real-IP", "X-Forwarded-For"},
              TrustedCIDRs:    trustedIp,
            }))
            c.Next(ctx)
          }
      }
   # 配置文件
  - path: conf/test/app.yml
    delims:
      - ""
      - ""
    body: |-
      env: test
      app:
        name: Admin
        type: web
        logger:
          level: debug
          encoding: json
          outputPaths:
            - stdout
            - logs/Admin
          errorOutputPaths:
            - stderr
          initialFields:
            app: Admin
          encoderConfig:
            #messageKey: msg
            levelKey: level
            nameKey: name
            TimeKey: time
            #CallerKey: caller
            #FunctionKey: func
            StacktraceKey: stacktrace
            LineEnding: "\n"
        errlog:
          level: warn
          encoding: json
          outputPaths:
            - stdout
            - logs/Admin
          errorOutputPaths:
            - stderr
          initialFields:
            app: Admin
          encoderConfig:
            #messageKey: msg
            levelKey: level
            nameKey: name
            TimeKey: time
            CallerKey: caller
            FunctionKey: func
            StacktraceKey: stacktrace
            LineEnding: "\n"
      redis:
      -
        name: pubRedis
        address: [ "nacosconfredis:6379" ]
        user:
        pwd:
        master:
      mysql:
      -
        name: pubMysql
        address: pubmysql
        port: 3306
        user: test
        pwd: 123456
        ssl: disable
        db: nacos
        sql_log: yes
        read_timeout: 100
        conn_timeout: 100
        write_timeout: 100
        char_set: utf8mb4
        max_idle_conns: 10
        max_open_conns: 500
      #nacos:
      #  -
      #    name: nacosConf
      #    url: http://nacosconf:8848/nacos
      #    contextPath: /nacos
      #    ns: 62c3bcf9-7948-4c26-a353-cebc0a7c9712
      #    user: dev
      #    pwd: 123456
      #    master:
      #    redis:
      #      name: base
      #      address: [ "nacosconfredis:6379" ]
      #      user:
      #      pwd:
      #      master:
      elastic:
      -
        name: pubEs
        host: [ "pubEs:9200" ]
        user: elastic
        pwd: SLmOE+pJcwsxbFrf-rzh
        read_timeout: 600ms
        conn_timeout: 80ms
        default_max_window_result: 0
        default_track_total_hits: 0
        auto_detect: false
        max_window_result:
          test: 1000
        track_total_hits:
          test: 2000
      #elasticNacos:
      #  name: nacosConf
      #  did: elastic
      #  group: elastic
      #  ns: 62c3bcf9-7948-4c26-a353-cebc0a7c9712
      pulsar:
      -
        name: pubPulsar
        address: [ "pubpulsar:6650" ]
      pulsarNacos:
        name: nacosConf
        did: pulsar
        group: pulsar
        ns: 62c3bcf9-7948-4c26-a353-cebc0a7c9712
  - path: conf/test/hertz.yml
    delims:
      - ""
      - ""
    body: |-
      hertz:
        address: ""
        port: 1081
        idle_timeout: 60s
        read_timeout: 10s
        max_request_body_size:
        write_timeout: 30s
        enable_pprof: false
        enable_gzip: true
        enable_access_log: true
        h2C: false
        service_find:
          type: nacos
          service_conf_name:
  - path: conf/test/pulsar.yml
    delims:
      - ""
      - ""
    body: |-
      topic_distribution:
        10: pubPulsar
      topic:
        -
          code: 10101001
          delay: 0
        -
          code_str: test
          delay: 0
          cluster: pubPulsar
  - path: conf/test/pulsar.yml
    delims:
      - ""
      - ""
    body: |-
      topicinit:  
        - 10101001